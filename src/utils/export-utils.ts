/**
 * Export Utilities
 * Functions to export tokens to various formats
 */

import {
  TokenDefinition,
  TMColorValue,
  TMSeparator,
  TMCaseStyle,
} from '../types/token-manager';

import {
  getState,
  getTokens,
} from '../types/token-manager-state';

// ============================================
// FORMAT NAME UTILITY
// ============================================

function formatName(name: string, caseStyle: TMCaseStyle): string {
  switch (caseStyle) {
    case 'camel':
      return name.replace(/-([a-z])/g, (_, c) => c.toUpperCase()).replace(/-/g, '');
    case 'snake':
      return name.replace(/-/g, '_');
    case 'pascal':
      return name.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
    default: // kebab
      return name;
  }
}

function formatPath(path: string[], name: string, separator: TMSeparator, caseStyle: TMCaseStyle): string {
  const formattedParts = [...path, name].map(p => formatName(p, caseStyle));
  return formattedParts.join(separator);
}

// ============================================
// JSON EXPORT (Design Tokens Format)
// Compatible with Style Dictionary, Tokens Studio, Storybook
// ============================================

export interface DTCFToken {
  $type: string;
  $value: any;
  $description?: string;
  $extensions?: Record<string, any>;
}

export function exportToJSON(): string {
  const state = getState();
  const tokens = getTokens().filter(t => t.enabled);
  const { separator, caseStyle } = state.settings;

  const result: Record<string, any> = {
    $version: '1.0.0',
    $name: 'Design Tokens',
    $description: 'Generated by Figma Token Manager',
    $timestamp: new Date().toISOString(),
  };

  // Group tokens by collection
  const primitives = tokens.filter(t => t.collection === 'Primitives');
  const semanticTokens = tokens.filter(t => t.collection === 'Tokens');
  const components = tokens.filter(t => t.collection === 'Components');

  if (primitives.length > 0) {
    result.primitives = buildNestedObject(primitives, separator, caseStyle);
  }

  if (semanticTokens.length > 0) {
    result.tokens = buildNestedObject(semanticTokens, separator, caseStyle);
  }

  if (components.length > 0) {
    result.components = buildNestedObject(components, separator, caseStyle);
  }

  return JSON.stringify(result, null, 2);
}

function buildNestedObject(
  tokens: TokenDefinition[], 
  separator: TMSeparator, 
  caseStyle: TMCaseStyle
): Record<string, any> {
  const result: Record<string, any> = {};

  for (const token of tokens) {
    let current = result;
    
    // Build nested structure from path
    for (const part of token.path) {
      const formattedPart = formatName(part, caseStyle);
      if (!current[formattedPart]) {
        current[formattedPart] = {};
      }
      current = current[formattedPart];
    }

    // Add token value
    const formattedName = formatName(token.name, caseStyle);
    current[formattedName] = buildTokenValue(token);
  }

  return result;
}

function buildTokenValue(token: TokenDefinition): DTCFToken {
  let type: string;
  let value: any;

  switch (token.type) {
    case 'COLOR':
      type = 'color';
      const colorValue = token.value as TMColorValue;
      value = colorValue.hex;
      break;
    case 'NUMBER':
      type = 'number';
      value = token.value;
      break;
    case 'STRING':
      type = 'string';
      value = token.value;
      break;
    case 'BOOLEAN':
      type = 'boolean';
      value = token.value;
      break;
    default:
      type = 'string';
      value = String(token.value);
  }

  const result: DTCFToken = {
    $type: type,
    $value: value,
  };

  if (token.description) {
    result.$description = token.description;
  }

  // Add reference info if exists
  if (token.references) {
    result.$extensions = {
      'com.figma': {
        references: token.references,
      },
    };
  }

  return result;
}

// ============================================
// STORYBOOK EXPORT (Flat tokens for Storybook)
// ============================================

export function exportToStorybook(): string {
  const state = getState();
  const tokens = getTokens().filter(t => t.enabled);
  const { separator, caseStyle } = state.settings;

  const result: Record<string, any> = {
    colors: {},
    spacing: {},
    borderRadius: {},
    typography: {},
    shadows: {},
    opacity: {},
  };

  for (const token of tokens) {
    const fullPath = formatPath(token.path, token.name, separator, caseStyle);

    if (token.type === 'COLOR') {
      const colorValue = token.value as TMColorValue;
      
      // Organize by collection and path
      if (token.collection === 'Primitives') {
        if (!result.colors.primitives) result.colors.primitives = {};
        setNestedValue(result.colors.primitives, token.path, token.name, colorValue.hex, caseStyle);
      } else if (token.collection === 'Tokens') {
        if (!result.colors.semantic) result.colors.semantic = {};
        setNestedValue(result.colors.semantic, token.path, token.name, colorValue.hex, caseStyle);
      } else {
        if (!result.colors.components) result.colors.components = {};
        setNestedValue(result.colors.components, token.path, token.name, colorValue.hex, caseStyle);
      }
    } else if (token.type === 'NUMBER') {
      // Categorize number tokens
      const pathFirst = token.path[0]?.toLowerCase() || '';
      if (pathFirst.includes('spacing') || pathFirst.includes('space')) {
        setNestedValue(result.spacing, token.path, token.name, token.value, caseStyle);
      } else if (pathFirst.includes('radius') || pathFirst.includes('border')) {
        setNestedValue(result.borderRadius, token.path, token.name, token.value, caseStyle);
      } else if (pathFirst.includes('opacity')) {
        setNestedValue(result.opacity, token.path, token.name, token.value, caseStyle);
      }
    }
  }

  // Clean up empty categories
  for (const key of Object.keys(result)) {
    if (Object.keys(result[key]).length === 0) {
      delete result[key];
    }
  }

  return JSON.stringify(result, null, 2);
}

function setNestedValue(
  obj: Record<string, any>, 
  path: string[], 
  name: string, 
  value: any,
  caseStyle: TMCaseStyle
): void {
  let current = obj;
  
  for (const part of path) {
    const formattedPart = formatName(part, caseStyle);
    if (!current[formattedPart]) {
      current[formattedPart] = {};
    }
    current = current[formattedPart];
  }

  const formattedName = formatName(name, caseStyle);
  current[formattedName] = value;
}

// ============================================
// CSS VARIABLES EXPORT
// ============================================

export function exportToCSS(): string {
  const state = getState();
  const tokens = getTokens().filter(t => t.enabled);
  const { caseStyle } = state.settings;

  const lines: string[] = [
    '/**',
    ' * Design Tokens - CSS Variables',
    ` * Generated: ${new Date().toISOString()}`,
    ' */',
    '',
    ':root {',
  ];

  // Group by collection
  const primitives = tokens.filter(t => t.collection === 'Primitives');
  const semanticTokens = tokens.filter(t => t.collection === 'Tokens');
  const components = tokens.filter(t => t.collection === 'Components');

  if (primitives.length > 0) {
    lines.push('  /* ==================== */');
    lines.push('  /* PRIMITIVES */');
    lines.push('  /* ==================== */');
    addCSSVariables(lines, primitives, caseStyle);
  }

  if (semanticTokens.length > 0) {
    lines.push('');
    lines.push('  /* ==================== */');
    lines.push('  /* SEMANTIC TOKENS */');
    lines.push('  /* ==================== */');
    addCSSVariables(lines, semanticTokens, caseStyle);
  }

  if (components.length > 0) {
    lines.push('');
    lines.push('  /* ==================== */');
    lines.push('  /* COMPONENT TOKENS */');
    lines.push('  /* ==================== */');
    addCSSVariables(lines, components, caseStyle);
  }

  lines.push('}');

  return lines.join('\n');
}

function addCSSVariables(lines: string[], tokens: TokenDefinition[], caseStyle: TMCaseStyle): void {
  // Group tokens by first path segment
  const groups: Record<string, TokenDefinition[]> = {};

  for (const token of tokens) {
    const group = token.path[0] || 'other';
    if (!groups[group]) {
      groups[group] = [];
    }
    groups[group].push(token);
  }

  for (const [group, groupTokens] of Object.entries(groups)) {
    lines.push(`  /* ${group} */`);

    for (const token of groupTokens) {
      const varName = buildCSSVarName(token, caseStyle);
      const value = buildCSSValue(token);
      lines.push(`  --${varName}: ${value};`);
    }

    lines.push('');
  }
}

function buildCSSVarName(token: TokenDefinition, caseStyle: TMCaseStyle): string {
  const parts = [...token.path, token.name];
  return parts.map(p => formatName(p, caseStyle === 'camel' ? 'kebab' : caseStyle)).join('-');
}

function buildCSSValue(token: TokenDefinition): string {
  switch (token.type) {
    case 'COLOR':
      return (token.value as TMColorValue).hex;
    case 'NUMBER':
      return String(token.value);
    case 'BOOLEAN':
      return token.value ? '1' : '0';
    default:
      return String(token.value);
  }
}

// ============================================
// SCSS VARIABLES EXPORT
// ============================================

export function exportToSCSS(): string {
  const state = getState();
  const tokens = getTokens().filter(t => t.enabled);
  const { caseStyle } = state.settings;

  const lines: string[] = [
    '//',
    '// Design Tokens - SCSS Variables',
    `// Generated: ${new Date().toISOString()}`,
    '//',
    '',
  ];

  // Group by collection
  const primitives = tokens.filter(t => t.collection === 'Primitives');
  const semanticTokens = tokens.filter(t => t.collection === 'Tokens');
  const components = tokens.filter(t => t.collection === 'Components');

  if (primitives.length > 0) {
    lines.push('// ====================');
    lines.push('// PRIMITIVES');
    lines.push('// ====================');
    lines.push('');
    addSCSSMaps(lines, primitives, 'primitives', caseStyle);
  }

  if (semanticTokens.length > 0) {
    lines.push('// ====================');
    lines.push('// SEMANTIC TOKENS');
    lines.push('// ====================');
    lines.push('');
    addSCSSMaps(lines, semanticTokens, 'tokens', caseStyle);
  }

  if (components.length > 0) {
    lines.push('// ====================');
    lines.push('// COMPONENT TOKENS');
    lines.push('// ====================');
    lines.push('');
    addSCSSMaps(lines, components, 'components', caseStyle);
  }

  return lines.join('\n');
}

function addSCSSMaps(
  lines: string[], 
  tokens: TokenDefinition[], 
  collectionName: string,
  caseStyle: TMCaseStyle
): void {
  // Group by first path segment
  const groups: Record<string, TokenDefinition[]> = {};

  for (const token of tokens) {
    const group = token.path[0] || 'other';
    if (!groups[group]) {
      groups[group] = [];
    }
    groups[group].push(token);
  }

  for (const [group, groupTokens] of Object.entries(groups)) {
    const mapName = `$${collectionName}-${formatName(group, caseStyle)}`;
    lines.push(`${mapName}: (`);

    for (const token of groupTokens) {
      const keyParts = [...token.path.slice(1), token.name];
      const key = keyParts.map(p => formatName(p, caseStyle)).join('-');
      const value = buildCSSValue(token);
      lines.push(`  '${key}': ${value},`);
    }

    lines.push(');');
    lines.push('');
  }
}

// ============================================
// TAILWIND CONFIG EXPORT
// ============================================

export function exportToTailwind(): string {
  const state = getState();
  const tokens = getTokens().filter(t => t.enabled && t.collection === 'Primitives');
  const { caseStyle } = state.settings;

  const colors: Record<string, any> = {};

  for (const token of tokens) {
    if (token.type !== 'COLOR') continue;

    const colorValue = token.value as TMColorValue;
    
    // Group by color name (second path segment usually)
    const colorGroup = token.path[1] || token.path[0] || 'other';
    const formattedGroup = formatName(colorGroup, caseStyle);

    if (!colors[formattedGroup]) {
      colors[formattedGroup] = {};
    }

    // Extract shade number from token name (e.g., 'brand-500' -> 500)
    const shadeMatch = token.name.match(/(\d+)$/);
    const shade = shadeMatch ? shadeMatch[1] : 'DEFAULT';

    colors[formattedGroup][shade] = colorValue.hex;
  }

  const config = {
    theme: {
      extend: {
        colors,
      },
    },
  };

  const lines = [
    '/**',
    ' * Tailwind CSS Color Configuration',
    ` * Generated: ${new Date().toISOString()}`,
    ' * Add this to your tailwind.config.js',
    ' */',
    '',
    'module.exports = ' + JSON.stringify(config, null, 2),
  ];

  return lines.join('\n');
}

// ============================================
// FIGMA VARIABLES EXPORT (for sync)
// ============================================

export interface FigmaVariableExport {
  name: string;
  value: { r: number; g: number; b: number; a: number } | number | string | boolean;
  description?: string;
  collection: string;
  mode?: 'light' | 'dark';
}

export function exportToFigmaVariables(): FigmaVariableExport[] {
  const state = getState();
  const tokens = getTokens().filter(t => t.enabled);
  const { separator } = state.settings;

  const variables: FigmaVariableExport[] = [];

  for (const token of tokens) {
    let value: FigmaVariableExport['value'];

    switch (token.type) {
      case 'COLOR':
        const colorValue = token.value as TMColorValue;
        // Ensure we have rgba object with r, g, b, a properties
        // Figma expects values in 0-1 range, so normalize from 0-255
        if (colorValue && colorValue.rgba && 
            typeof colorValue.rgba.r === 'number' &&
            typeof colorValue.rgba.g === 'number' &&
            typeof colorValue.rgba.b === 'number') {
          // Check if values are in 0-255 range and normalize to 0-1
          const r = colorValue.rgba.r > 1 ? colorValue.rgba.r / 255 : colorValue.rgba.r;
          const g = colorValue.rgba.g > 1 ? colorValue.rgba.g / 255 : colorValue.rgba.g;
          const b = colorValue.rgba.b > 1 ? colorValue.rgba.b / 255 : colorValue.rgba.b;
          value = {
            r,
            g,
            b,
            a: colorValue.rgba.a ?? 1
          };
        } else if (colorValue && typeof colorValue === 'object' && 'r' in colorValue) {
          // Direct RGBA format
          const directRgba = colorValue as unknown as { r: number; g: number; b: number; a?: number };
          // Check if values are in 0-255 range and normalize to 0-1
          const r = directRgba.r > 1 ? directRgba.r / 255 : directRgba.r;
          const g = directRgba.g > 1 ? directRgba.g / 255 : directRgba.g;
          const b = directRgba.b > 1 ? directRgba.b / 255 : directRgba.b;
          value = {
            r,
            g,
            b,
            a: directRgba.a ?? 1
          };
        } else {
          // Skip invalid color tokens
          console.warn(`Invalid color value for token ${token.name}:`, colorValue);
          continue;
        }
        break;
      case 'NUMBER':
        value = token.value as number;
        break;
      case 'STRING':
        value = token.value as string;
        break;
      case 'BOOLEAN':
        value = token.value as boolean;
        break;
      default:
        value = String(token.value);
    }

    variables.push({
      name: token.fullPath,
      value,
      description: token.description,
      collection: token.collection,
    });
  }

  return variables;
}

// ============================================
// MAIN EXPORT FUNCTION
// ============================================

export type ExportFormat = 'json' | 'storybook' | 'css' | 'scss' | 'tailwind' | 'figma';

export function exportTokens(format: ExportFormat): string | FigmaVariableExport[] {
  switch (format) {
    case 'json':
      return exportToJSON();
    case 'storybook':
      return exportToStorybook();
    case 'css':
      return exportToCSS();
    case 'scss':
      return exportToSCSS();
    case 'tailwind':
      return exportToTailwind();
    case 'figma':
      return exportToFigmaVariables();
    default:
      return exportToJSON();
  }
}

// ============================================
// DOWNLOAD HELPER
// ============================================

export function getExportFilename(format: ExportFormat): string {
  const timestamp = new Date().toISOString().split('T')[0];
  
  switch (format) {
    case 'json':
      return `design-tokens-${timestamp}.json`;
    case 'storybook':
      return `storybook-tokens-${timestamp}.json`;
    case 'css':
      return `tokens-${timestamp}.css`;
    case 'scss':
      return `_tokens-${timestamp}.scss`;
    case 'tailwind':
      return `tailwind-tokens-${timestamp}.js`;
    case 'figma':
      return `figma-variables-${timestamp}.json`;
    default:
      return `tokens-${timestamp}.json`;
  }
}

export function getExportMimeType(format: ExportFormat): string {
  switch (format) {
    case 'css':
      return 'text/css';
    case 'scss':
      return 'text/x-scss';
    case 'tailwind':
      return 'application/javascript';
    default:
      return 'application/json';
  }
}
